\section{Descrizione Design Pattern}{
	\subsection{Design Pattern Architetturali}{
			\subsubsection{Pattern Architetturale a Microservizi}{
				\begin{figure}[ht]
					\centering
					\includegraphics{\docsImg ArchitetturaMicroservizi.png}
					\caption{Illustrazione Architettura a Microservizi}
					\label{Illustrazione Architettura a Microservizi}
				\end{figure}
				Il pattern architetturale a microservizi è un pattern innovativo che va a sostituire la vecchia filosofia dei sistemi monolitici dedicato e alle architettura orientate ai servizi.
				\begin{itemize}\itemsep1pt
					\item \textbf{Descrizione Generale} : il primo concetto che caratterizza il pattern è l'idea di unità separate distribuite. Questo aumenta la scalabilità e un alto grado di disaccoppiamento all'interno della nostra applicazione. Forse il fattore più importante è pensare al microservizio non come componente dell'architettura ma come servizio in se, che può variare la propria granularità da un singolo modulo a gran parte dell'applicazione.\\
					Un altro concetto chiave all'interno del modello microservices architettura è che si tratta di un'architettura distribuita, il che significa che tutti i componenti all'interno dell'architettura sono completamente disaccoppiati da un altro e sono accessibili attraverso una sorta di protocollo di accesso remoto.\\
					L'architettura stessa si è evoluta da problemi riscontrati in altri modelli e non è in attesa che un problema si verifichi. In particolare si è evoluta da due principali pattern architetturali: le applicazioni monolitiche sviluppate utilizzando il modello di architettura a strati e applicazioni distribuite sviluppate attraverso l'architettura modello orientato ai servizi.\\
					In generale, nell'architettura a microservizi, ogni singolo servizio è autonomo rispetto agli altri, di conseguenza può raggiungere l’ambiente di produzione in modo indipendente dagli altri, testato e distribuito, senza che tale attività abbia effetti drammatici sul resto del sistema. Disporre di un processo di deployment snello e veloce consente di poter aggiungere o modificare funzionalità di un sistema software in modo efficace ed efficiente, rispondendo alle necessità di mercato e utenti sempre più esigenti.\\
					L'altro percorso evolutivo che ha portato al modello architetturale a microservizi proviene da problemi rilevati con le applicazioni di attuazione dell'architettura modello orientato ai servizi (\textit{SOA}\pedice{G}). Mentre il modello SOA è molto potente e offre livelli senza precedenti di astrazione, connettività eterogenea, orchestrazione dei servizi, e la promessa di allineare gli obiettivi di business con funzionalità IT, è comunque complesso, costoso, onnipresente, difficile da capire e mettere in atto, e di solito è eccessivo per la maggior parte delle applicazioni.\\
					\item \textbf{Considerazioni} : Robustezza, miglior scalabilità, erogazione continua. Con piccole componenti miglioriamo la distribuzione e questo risolve i problemi delle applicazioni monolitiche e SOA. Abbiamo una disponibilità di servizio continua.\\
					Sorgono i problemi della distribuzione e della disponibilità dei sistemi remoti. Non si può utilizzare nel caso abbiamo bisogno di un orchestratore, a meno che non rimanga all'interno di un microservizio, e nemmeno nel caso abbiamo bisogno di transazionalità.
					\item \textbf{Analisi del Pattern} :
					\small %rippicciolisce il testo
					{\renewcommand\arraystretch{1.2} %aumenta l'altezza di ogni riga
						\begin{tabular}{|l|c|l|}
							\hline
							{\textbf{Caratteristica}}&{\textbf{Valutazione}}&{\textbf{Descrizione}}\\
							\hline
							\textit{Agilità} & + & Cambiamenti isolati , veloci e di facile sviluppo \\
							\hline
							\textbf{Implementazione} & + & Di natura singolare e univoca quindi facili da implementare \\
							\hline
							\textbf{Testabilità} & + & Visto l'isolamento delle funzioni business il test può essere più specifico. Piccola possibilità di regressione \\
							\hline
							\textbf{Performance} & - & Essendo per la maggior parte nella rete è difficile mantenere delle prestazioni massime e costanti \\
							\hline
							\textbf{Scalabilità} & + & Ogni componente può essere separato e quindi vi è la massima scalabilità \\
							\hline
							\textbf{Sviluppo} & + & Piccoli e isolati componenti facilitano lo sviluppo \\
							\hline
						\end{tabular}
					}
				\end{itemize}
		}
		\subsubsection{Data Access Object (DAO)}{
			Il DAO (Data Access Object) è un pattern architetturale per la gestione della persistenza: si tratta fondamentalmente di una classe con relativi metodi che rappresenta un'entità tabellare di un database relazionale.
			\begin{itemize}\itemsep1pt
				\item \textbf{Descrizione Generale} : Usata principalmente in applicazioni web (come ad esempio Java EE), per stratificare e isolare l'accesso ad una tabella tramite query (poste all'interno dei metodi della classe) ovvero al data layer da parte della business logic creando un maggiore livello di astrazione ed una più facile manutenibilità. I metodi del DAO con le rispettive query dentro verranno così richiamati dalle classi della business logic.
				\item \textbf{Considerazioni} : Le Data Access Objects si fanno carico di gestire il codice SQL, mentre tutto ciò é trasparente rispetto alle corrispondenti classi di dominio e di controllo.\\ 
				A livello di logica dell'applicazione siamo fortemente orientati agli oggetti: ragioniamo solo in termini di Domain Objects, cioè dei concetti pertinenti al dominio dell'applicazione, e non possiamo mai utilizzare i metodi di accesso diretto alla base dati forniti dai DAO. %INCOMPLETO SECONDO ME
				\item \textbf{Analisi del Pattern} :
				\small %rippicciolisce il testo
				{\renewcommand\arraystretch{1.2} %aumenta l'altezza di ogni riga
					\begin{tabular}{|l|c|l|}
						\hline
						{\textbf{Caratteristica}}&{\textbf{Valutazione}}&{\textbf{Descrizione}}\\
						\hline
						\textit{Agilità} & + & Facile da sviluppare e modificare nel caso di aggiunta di funzioni \\
						\hline
						\textbf{Implementazione} & + & Si crea una classe DAO per ogni classe che rappresenta entità del dominio di applicazione \\
						\hline
						\textbf{Testabilità} & + & Si testa in seguito alla costruzione del DB. Mantenendo separate le componenti è semplice da testare \\
						\hline
						\textbf{Performance} & n.q. & Estende il database, quindi le performance derivano dalla sua costruzione \\
						\hline
						\textbf{Scalabilità} & + & All'aggiunta di classi e elementi basta estendere la classe agevolmente\\
						\hline
						\textbf{Sviluppo} & + & %MANCA \\
						\hline
					\end{tabular}
				}
			\end{itemize}
		}
	
		\subsubsection{Model View ViewModel}{
			%MANCA
		}
	}
	\subsection{Design Pattern Creazionali}{
		\subsubsection{Abstract Factory}{
			\begin{figure}[ht]
				\centering
				\includegraphics{\docsImg AbstractFactory.png}
				\caption{Illustrazione Pattern Abstract Factory}
				\label{Illustrazione Pattern Abstract Factory}
			\end{figure}
			L'Abstract Factory fornisce un'interfaccia per creare famiglie di oggetti connessi o dipendenti tra loro, in modo che non ci sia necessità da parte dei client di specificare i nomi delle classi concrete all'interno del proprio codice.
			In questo modo si permette che un sistema sia indipendente dall'implementazione degli oggetti concreti e che il client, attraverso l'interfaccia, utilizzi diverse famiglie di prodotti.
			\begin{itemize}\itemsep1pt
				\item \textbf{Descrizione Generale} : Il pattern Abstract Factory definisce un'interfaccia con una serie di metodi per creare una famiglia di prodotti correlati. La famiglia di oggetti correlati è definita attraverso una serie di tipi di elementi. L'attuazione dei tipi di prodotto è delegata a un insieme di sottoclassi di elementi concreti. La creazione delle classi di prodotto concrete è attuato per serie di classi factory concrete. Il pattern Abstract Factory rinvia la creazione degli elementi concreti alle classi "di fabbrica" concrete che implementa l'Abstract Factory. L'oggetto client è disaccoppiato dalle classi di prodotti e le classi di fabbrica attraverso l'interfaccia Abstract Factory. Il nucleo del pattern Abstract Factory è quello di creare un gruppo di oggetti correlati che potrebbero avere diverse implementazioni. Il sistema è quindi indipendente dell'attuazione dei tipi di prodotto. Il pattern Abstract Factory permette anche il sistema per sostituire un insieme di classi di prodotti correlati con un altro set, cambiando la classe fabbrica.
				\item \textbf{Considerazioni} : Questo pattern è utile quando si vuole un sistema indipendente da come gli oggetti vengono creati, composti e rappresentati. Si vuole permettere la configurazione del sistema come scelta tra diverse famiglie di prodotti. I prodotti che sono organizzati in famiglie siano vincolati ad essere utilizzati con prodotti della stessa famiglia. Si vuole infine fornire una libreria di classi mostrando solo le interfacce e nascondendo le implementazioni.
				\item \textbf{Analisi del Pattern} :
				\small %rippicciolisce il testo
				{\renewcommand\arraystretch{1.2} %aumenta l'altezza di ogni riga
					\begin{tabular}{|l|c|l|}
						\hline
						{\textbf{Caratteristica}}&{\textbf{Valutazione}}&{\textbf{Descrizione}}\\
						\hline
						\textit{Agilità} & + & È nella definizione del pattern creazionale la possibilità di creare oggetti a partire da qualsiasi classe. \\
						\hline
						\textbf{Implementazione} & + & Singola istanza della factory. Semplicità di aggiungere una nuova famiglia. Difficile però aggiungere un'interfaccia. \\
						\hline
						\textbf{Testabilità} & +/- & Isolamento di tipo concreto e quindi facilmente verificabile. Nella modifica c'è bisogno di una riverifica generale. \\
						\hline
						\textbf{Performance} & n.q. & Dipende tutto dall'implementazione della classe su cui si vuole fare la factory. \\
						\hline
						\textbf{Scalabilità} & - & Aggiungere nuove famiglie di prodotti è difficile perché l’insieme di prodotti gestiti è legato all'interfaccia della factory. \\
						\hline
						\textbf{Sviluppo} & + & L'interfaccia di per se è di facile implementazione e compare in un unico punto del codice. \\
						\hline
					\end{tabular}
				}
			\end{itemize}
		}
	
		\subsubsection{Dependency Injection}{
			%MANCA
		}	
	}
	\subsection{Design Pattern Strutturali}{
		
	}
	\subsection{Design Pattern Comportamentali}{
		
	}
}