\section{Descrizione Design Pattern}{
	\subsection{Design Pattern Architetturali}{
			\subsubsection{Pattern Architetturale a Microservizi}{
				\begin{figure}[ht]
					\centering
					\includegraphics{\docsImg ArchitetturaMicroservizi.png}
					\caption{Illustrazione Architettura a Microservizi}
					\label{Illustrazione Architettura a Microservizi}
				\end{figure}
				Il pattern architetturale a microservizi è un pattern innovativo che va a sostituire la vecchia filosofia dei sistemi monolitici dedicato e alle architettura orientate ai servizi.
				\begin{itemize}\itemsep1pt
					\item \textbf{Descrizione Generale} : il primo concetto che caratterizza il pattern è l'idea di unità separate distribuite. Questo aumenta la scalabilità e un alto grado di disaccoppiamento all'interno della nostra applicazione. Forse il fattore più importante è pensare al microservizio non come componente dell'architettura ma come servizio in se, che può variare la propria granularità da un singolo modulo a gran parte dell'applicazione.\\
					Un altro concetto chiave all'interno del modello microservices architettura è che si tratta di un'architettura distribuita, il che significa che tutti i componenti all'interno dell'architettura sono completamente disaccoppiati da un altro e sono accessibili attraverso una sorta di protocollo di accesso remoto.\\
					L'architettura stessa si è evoluta da problemi riscontrati in altri modelli e non è in attesa che un problema si verifichi. In particolare si è evoluta da due principali pattern architetturali: le applicazioni monolitiche sviluppate utilizzando il modello di architettura a strati e applicazioni distribuite sviluppate attraverso l'architettura modello orientato ai servizi.\\
					In generale, nell'architettura a microservizi, ogni singolo servizio è autonomo rispetto agli altri, di conseguenza può raggiungere l’ambiente di produzione in modo indipendente dagli altri, testato e distribuito, senza che tale attività abbia effetti drammatici sul resto del sistema. Disporre di un processo di deployment snello e veloce consente di poter aggiungere o modificare funzionalità di un sistema software in modo efficace ed efficiente, rispondendo alle necessità di mercato e utenti sempre più esigenti.\\
					L'altro percorso evolutivo che ha portato al modello architetturale a microservizi proviene da problemi rilevati con le applicazioni di attuazione dell'architettura modello orientato ai servizi (\textit{SOA}\pedice{G}). Mentre il modello SOA è molto potente e offre livelli senza precedenti di astrazione, connettività eterogenea, orchestrazione dei servizi, e la promessa di allineare gli obiettivi di business con funzionalità IT, è comunque complesso, costoso, onnipresente, difficile da capire e mettere in atto, e di solito è eccessivo per la maggior parte delle applicazioni.\\
					\item \textbf{Considerazioni} : Robustezza, miglior scalabilità, erogazione continua. Con piccole componenti miglioriamo la distribuzione e questo risolve i problemi delle applicazioni monolitiche e SOA. Abbiamo una disponibilità di servizio continua.\\
					Sorgono i problemi della distribuzione e della disponibilità dei sistemi remoti. Non si può utilizzare nel caso abbiamo bisogno di un orchestratore, a meno che non rimanga all'interno di un microservizio, e nemmeno nel caso abbiamo bisogno di transazionalità.
					\item \textbf{Analisi del Pattern} :
					\small %rippicciolisce il testo
					{\renewcommand\arraystretch{1.2} %aumenta l'altezza di ogni riga
						\begin{tabular}{|l|c|l|}
							\hline
							{\textbf{Caratteristica}}&{\textbf{Valutazione}}&{\textbf{Descrizione}}\\
							\hline
							\textit{Agilità} & + & Cambiamenti isolati , veloci e di facile sviluppo \\
							\hline
							\textbf{Implementazione} & + & Di natura singolare e univoca quindi facili da implementare \\
							\hline
							\textbf{Testabilità} & + & Visto l'isolamento delle funzioni business il test può essere più specifico. Piccola possibilità di regressione \\
							\hline
							\textbf{Performance} & - & Essendo per la maggior parte nella rete è difficile mantenere delle prestazioni massime e costanti \\
							\hline
							\textbf{Scalabilità} & + & Ogni componente può essere separato e quindi vi è la massima scalabilità \\
							\hline
							\textbf{Sviluppo} & + & Piccoli e isolati componenti facilitano lo sviluppo \\
							\hline
						\end{tabular}
					}
				\end{itemize}
		}
		\subsubsection{Data Access Object (DAO)}{
			Il DAO (Data Access Object) è un pattern architetturale per la gestione della persistenza: si tratta fondamentalmente di una classe con relativi metodi che rappresenta un'entità tabellare di un database relazionale.
			\begin{itemize}\itemsep1pt
				\item \textbf{Descrizione Generale} : Usata principalmente in applicazioni web (come ad esempio Java EE), per stratificare e isolare l'accesso ad una tabella tramite query (poste all'interno dei metodi della classe) ovvero al data layer da parte della business logic creando un maggiore livello di astrazione ed una più facile manutenibilità. I metodi del DAO con le rispettive query dentro verranno così richiamati dalle classi della business logic.
				\item \textbf{Considerazioni} : Le Data Access Objects si fanno carico di gestire il codice SQL, mentre tutto ciò é trasparente rispetto alle corrispondenti classi di dominio e di controllo.\\ 
				A livello di logica dell'applicazione siamo fortemente orientati agli oggetti: ragioniamo solo in termini di Domain Objects, cioè dei concetti pertinenti al dominio dell'applicazione, e non possiamo mai utilizzare i metodi di accesso diretto alla base dati forniti dai DAO. %INCOMPLETO SECONDO ME
				\item \textbf{Analisi del Pattern} :
				\small %rippicciolisce il testo
				{\renewcommand\arraystretch{1.2} %aumenta l'altezza di ogni riga
					\begin{tabular}{|l|c|l|}
						\hline
						{\textbf{Caratteristica}}&{\textbf{Valutazione}}&{\textbf{Descrizione}}\\
						\hline
						\textit{Agilità} & + & Facile da sviluppare e modificare nel caso di aggiunta di funzioni \\
						\hline
						\textbf{Implementazione} & + & Si crea una classe DAO per ogni classe che rappresenta entità del dominio di applicazione \\
						\hline
						\textbf{Testabilità} & + & Si testa in seguito alla costruzione del DB. Mantenendo separate le componenti è semplice da testare \\
						\hline
						\textbf{Performance} & n.q. & Estende il database, quindi le performance derivano dalla sua costruzione \\
						\hline
						\textbf{Scalabilità} & + & All'aggiunta di classi e elementi basta estendere la classe agevolmente\\
						\hline
						\textbf{Sviluppo} & n.q. & %INCOMPLETO \\
						\hline
					\end{tabular}
				}
			\end{itemize}
		}
	
		\subsubsection{Model View ViewModel}{
			\begin{figure}[ht]
				\centering
				\includegraphics{\docsImg ArchitetturaMVVM.png}
				\caption{Illustrazione Model View ViewModel}
				\label{Illustrazione Model View ViewModel}
			\end{figure}
			Il Model–view–viewmodel (MVVM) è un pattern software architetturale o schema di progettazione software. È una variante del pattern "Presentation Model design" di Martin Fowler.
			\begin{itemize}\itemsep1pt
				\item \textbf{Descrizione Generale} : Lo MVVM astrae lo stato di "view" (visualizzazione) e il comportamento. Sebbene, dove il modello di "presentazione" astrae una vista (crea un view model ) in una maniera che non dipende da una specifica piattaforma interfaccia utente. In pratica separa lo sviluppo dell'interfaccia utente dalla business logic\textsubscript{g}.\\
				Le componenti sono le seguenti:
				\begin{itemize}
					\item Il \textbf{Model} rappresenta il punto di accesso ai dati. Trattasi di una o più classi che leggono dati dal DB, oppure da un servizio Web di qualsivoglia natura.
					\item La \textbf{View} rappresenta la vista dell'applicazione, l'interfaccia grafica che mostrerà i dati.
					\item Il \textbf{ViewModel} è il punto di incontro tra la View e il Model: i dati ricevuti da quest’ultimo sono elaborati per essere presentati e passati alla View.
				\end{itemize}
				Il fulcro del funzionamento di questo pattern è la creazione di un componente, il ViewModel appunto, che rappresenta tutte le informazioni e i comportamenti della corrispondente View. La View si limita infatti, a visualizzare graficamente quanto esposto dal ViewModel, a riflettere in esso i suoi cambi di stato oppure ad attivarne dei comportamenti.
				\item \textbf{Considerazioni} : L'utente interagisce solo ed unicamente con li View. E la comunicazione di stato è comunicata al ViewModel. Come risposta al cambio di stato o all'attivazione di un metodo il ViewModel invia un segnale o esegue un operazione sul Model e aggiorna il proprio stato. Il nuovo stato del ViewModel si riflette sulla View.\\
				È da sottolineare il fatto che il ViewModel mantiene nel proprio stato non solo le informazioni recuperate attraverso il Model, ma anche lo stato attuale della visualizzazione: ciò gli consente di essere del tutto disaccoppiato dalla View. Inoltre il processo step-by-step descritto in precedenza risulta essere un “two-way”, funziona cioè in entrambe le direzioni.\\
				AngularJS implementa un modello basato su questa visione del pattern e utilizza HTML come linguaggio di templating, non richiede operazioni di DOM refresh e controlla attivamente le azioni utente ed eventi nel browser. 
				\item \textbf{Analisi del Pattern} :
				\small %rippicciolisce il testo
				{\renewcommand\arraystretch{1.2} %aumenta l'altezza di ogni riga
					\begin{tabular}{|l|c|l|}
						\hline
						{\textbf{Caratteristica}}&{\textbf{Valutazione}}&{\textbf{Descrizione}}\\
						\hline
						\textit{Agilità} & + & È il classico pattern a 3 elementi ed è ideologia di agilità \\
						\hline
						\textbf{Implementazione} & + & Avendo netta distinzione tra gli elementi è facile l'implementazione e mantenerlo\\
						\hline
						\textbf{Testabilità} & + & Lo Unit Testing nel MVVM dove le componenti siano "separate" contribuisce alla progettazione di unità di test efficaci.\\
						\hline
						\textbf{Performance} & + & Rispetto al classico modello MVC è più snello e quindi a confronto è più veloce \\
						\hline
						\textbf{Scalabilità} & + & Possono essere modificati implementati differentemente essendo separati\\
						\hline
						\textbf{Sviluppo} & + & Ogni singolo elemento del team può concentrarsi allo sviluppo di ogni diverso elemento \\
						\hline
					\end{tabular}
				}
			\end{itemize}
		}
	}
	\subsection{Design Pattern Creazionali}{
		\subsubsection{Abstract Factory}{
			\begin{figure}[ht]
				\centering
				\includegraphics{\docsImg AbstractFactory.png}
				\caption{Illustrazione Pattern Abstract Factory}
				\label{Illustrazione Pattern Abstract Factory}
			\end{figure}
			L'Abstract Factory fornisce un'interfaccia per creare famiglie di oggetti connessi o dipendenti tra loro, in modo che non ci sia necessità da parte dei client di specificare i nomi delle classi concrete all'interno del proprio codice.
			In questo modo si permette che un sistema sia indipendente dall'implementazione degli oggetti concreti e che il client, attraverso l'interfaccia, utilizzi diverse famiglie di prodotti.
			\begin{itemize}\itemsep1pt
				\item \textbf{Descrizione Generale} : Il pattern Abstract Factory definisce un'interfaccia con una serie di metodi per creare una famiglia di prodotti correlati. La famiglia di oggetti correlati è definita attraverso una serie di tipi di elementi. L'attuazione dei tipi di prodotto è delegata a un insieme di sottoclassi di elementi concreti. La creazione delle classi di prodotto concrete è attuato per serie di classi factory concrete. Il pattern Abstract Factory rinvia la creazione degli elementi concreti alle classi "di fabbrica" concrete che implementa l'Abstract Factory. L'oggetto client è disaccoppiato dalle classi di prodotti e le classi di fabbrica attraverso l'interfaccia Abstract Factory. Il nucleo del pattern Abstract Factory è quello di creare un gruppo di oggetti correlati che potrebbero avere diverse implementazioni. Il sistema è quindi indipendente dell'attuazione dei tipi di prodotto. Il pattern Abstract Factory permette anche il sistema per sostituire un insieme di classi di prodotti correlati con un altro set, cambiando la classe fabbrica.
				\item \textbf{Considerazioni} : Questo pattern è utile quando si vuole un sistema indipendente da come gli oggetti vengono creati, composti e rappresentati. Si vuole permettere la configurazione del sistema come scelta tra diverse famiglie di prodotti. I prodotti che sono organizzati in famiglie siano vincolati ad essere utilizzati con prodotti della stessa famiglia. Si vuole infine fornire una libreria di classi mostrando solo le interfacce e nascondendo le implementazioni.
				\item \textbf{Analisi del Pattern} :
				\small %rippicciolisce il testo
				{\renewcommand\arraystretch{1.2} %aumenta l'altezza di ogni riga
					\begin{tabular}{|l|c|l|}
						\hline
						{\textbf{Caratteristica}}&{\textbf{Valutazione}}&{\textbf{Descrizione}}\\
						\hline
						\textit{Agilità} & + & È nella definizione del pattern creazionale la possibilità di creare oggetti a partire da qualsiasi classe. \\
						\hline
						\textbf{Implementazione} & + & Singola istanza della factory. Semplicità di aggiungere una nuova famiglia. Difficile però aggiungere un'interfaccia. \\
						\hline
						\textbf{Testabilità} & +/- & Isolamento di tipo concreto e quindi facilmente verificabile. Nella modifica c'è bisogno di una riverifica generale. \\
						\hline
						\textbf{Performance} & n.q. & Dipende tutto dall'implementazione della classe su cui si vuole fare la factory. \\
						\hline
						\textbf{Scalabilità} & - & Aggiungere nuove famiglie di prodotti è difficile perché l’insieme di prodotti gestiti è legato all'interfaccia della factory. \\
						\hline
						\textbf{Sviluppo} & + & L'interfaccia di per se è di facile implementazione e compare in un unico punto del codice. \\
						\hline
					\end{tabular}
				}
			\end{itemize}
		}
	
		\subsubsection{Dependency Injection}{
			%MANCA
		}	
	}
	\subsection{Design Pattern Strutturali}{
		
	}
	\subsection{Design Pattern Comportamentali}{
		
	}
}